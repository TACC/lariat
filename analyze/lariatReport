#!/usr/bin/env lua
-- -*- lua -*-
local cmd = arg[0]

local i,j = cmd:find(".*/")
local cmd_dir = "./"
if (i) then
   cmd_dir = cmd:sub(1,j)
end
package.path = cmd_dir .. "?.lua;" .. package.path
local floor     = math.floor
local lfs       = require("lfs")
local mod       = math.mod
execNameA       = {}

require("strict")
local BeautifulTbl = require("BeautifulTbl")
local Optiks       = require("Optiks")
local Version      = "1.4"
local master       = {}
require("serializeTbl")
require("string_split")
require("fileOps")
require("declare")
require("VarDump")
userT = {}
local Dbg = require("Dbg")


function processSgeT(sgeT, accT, execT, libT)
   for k, v in pairs(sgeT) do
      local execType   = v.execType
      local su         = v.numCores * v.runTime / 3600.0
      local t          = accT[execType] or { num = 0, su = 0, user = {} }
      t.num            = t.num + 1
      t.su             = t.su  + su
      t.user[v.user]   = (t.user[v.user] or 0) + 1
      accT[execType]   = t

      if (execType:find("^system:"))then
         accT.system.num = accT.system.num + 1
         accT.system.su  = accT.system.su  + su
      end

      local exec      = barefilename(v.exec)
      local t         = execT[exec] or { num=0, su = 0, job={id="", su = 0},userT={}}
      t.su            = t.su  + su
      t.num           = t.num + 1
      t.userT[v.user] = 1
      if (su > t.job.su) then
         t.job.su = su
         t.job.id = v.jobID
      end

      if (next(v.pkgT) ~= nil) then
         recordLibT(su, v.pkgT, libT)
      end
   end
end


function recordLibT(su, pkgT, libT)
   for k, v in pairs(pkgT) do
      local t            = libT[k] or { su = 0.0, flavor = {}, num = 0}
      t.su               = t.su  + su
      t.num              = t.num + 1
      t.flavor[v.flavor] = (t.flavor[v.flavor] or 0 ) + su
      libT[k]            = t
   end
end


function reportLibT(libT)
   local a = {}
   for k,v in pairs(libT) do
      a[#a+1] = {name=k, su=v.su, num=v.num}
   end
   if (#a > 0) then
      print("\nFound ",#a," shared libraries:")
   else
      print("\nFound no shared libraries\n")
      return
   end

   table.sort(a,function(x,y) return x.su > y.su end)
   local fmt = "%7.2f"
   local b   = {}

   b[#b+1] = { "Library Module Name ","Total SU Used ", "Number of Jobs" }
   b[#b+1] = { "------------------- ","------------- ", "--------------" }
   for i = 1, #a do
      local su = fmt:format(a[i].su)
      b[#b+1]  = {a[i].name, su, tostring(a[i].num)}
   end

   local bt = BeautifulTbl:new{tbl=b}
   io.stdout:write(bt:build_tbl(),"\n");
end


function displayExecT(a, msg)
   local b = {}
   local fmt = "%7.2f"

   print ("\n",msg,":\n")

   b[#b+1] = {"Exec Name", "Total SU used", "Number of Jobs", "Job ID", "Number of Users"}
   b[#b+1] = {"---------", "-------------", "--------------", "------", "---------------"}

   for i = 1,#a do
      local su = fmt:format(a[i].su)
      b[#b+1] = {a[i].name, su, tostring(a[i].num),a[i].id,tostring(a[i].numUsers)}
   end
   local bt = BeautifulTbl:new{tbl=b}
   io.stdout:write(bt:build_tbl(),"\n");
end

function reportTop(execT, execFile)
   local a = {}
   for k,v in pairs(execT) do
      local t = v.userT
      local icount = 0
      for _, _ in next, t do
         icount = icount + 1
      end
      a[#a+1] = {name=k, su=v.su, num=v.num, id=v.job.id, numUsers=icount}
   end

   -- Report Top SU jobs

   table.sort(a,function(x,y) return x.su > y.su end)

   local n = math.min(20,#a)
   
   --for i = 1, #a do
   --   print(i,",",a[i].su)
   --end
      

   local aa = {}
   local msg = "Top "..tostring(n).." SU jobs"
   for i = 1,n do
      aa[i] = a[i]
   end

   displayExecT(aa,msg)

   -- Report Top NUM jobs

   table.sort(a,function(x,y) return x.num > y.num end)

   local n = math.min(20,#a)
   
   --for i = 1, #a do
   --   print(i,",",a[i].su)
   --end
      

   local aa = {}
   local msg = "Top "..tostring(n).." NUM jobs"
   for i = 1,n do
      aa[i] = a[i]
   end

   displayExecT(aa,msg)

   if (execFile and isFile(execFile) ) then
      assert(loadfile(execFile))()

      aa = {}
      for i = 1, #a do
         for j = 1, #execNameA do
            if ( a[i].name:find(execNameA[j]) )then
               aa[#aa+1] = a[i]
            end
         end
      end

      msg = "Report of jobs from execfile"
      displayExecT(aa,msg)
   end


end
function masterTbl()
   return master
end

function main()

   local numTimes = 0
   local iuser = 0
   local unit  = 2
   local fence = unit

   local execT = {}
   local libT  = {}
   local accT  = {bss     = {num = 0, jobID = {} },
                  system  = {num = 0, su    =  0 },
   }

   options()
   local masterTbl  = masterTbl()
   local pargs      = masterTbl.pargs

   declare("sgeT",{})

   for i = 1,#pargs do
      loadfile(pargs[i])
      processSgeT(sgeT, execT, libT)
   end
   

   io.stdout:write("\n")

   local s = serializeTbl{indent=true, name="accT", value=accT}
   io.stdout:write("\n",s,"\n")
               
   processExecT(sgeT,execT)

   reportLibT(libT)   

   reportTop(execT, masterTbl.execFile)

end
function options()
   local masterTbl = masterTbl()
   local usage         = "Usage: processLDDjob [options]"
   local cmdlineParser = Optiks:new{usage=usage, version=Version}

   cmdlineParser:add_option{ 
      name    = {'-f','--execFile'},
      dest    = 'execFile',
      action  = 'store',
      default = nil,
      help    = "File containing a list of executables in a lua Table execNameA={}",
   }


   local optionTbl, pargs = cmdlineParser:parse(arg)

   for v in pairs(optionTbl) do
      masterTbl[v] = optionTbl[v]
   end
   masterTbl.pargs = pargs

end

main()
