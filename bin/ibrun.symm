#!/bin/bash
# -*-sh-*-
# ---------------------------------------------------------------------
# Stampede Symmetric ibrun
#
# ---------------------------------------------------------------------
#set -x

function usage {
  ## User asked for a help message.  Exit after printing it.
    echo " "
    echo "Usage: `basename $0` -m ./<mic_executable>  -c ./<cpu_executable> "
    echo " "
    echo "Set the number of tasks per mic with the environment variable."
    echo "   MIC_PPN(Default=4)"
    echo "Set the number of threads per mic task with the environment variable."
    echo "   MIC_OMP_NUM_THREADS(Default=30)"
    echo "Set the number of host threads."
    echo "   OMP_NUM_THREADS(Default=1)"
    echo "The number of host tasks and layout will correspond to the"
    echo "  SLURM settings."
    echo "To change the number of host tasks set MY_NSLOTS"
    echo " "
    echo "The total number of MPI tasks will be: "
    echo " # of host tasks(set by SLURM) + (# of nodes x $MIC_PPN) "
    echo " "
    echo "Example: parallel environment -n 32 -N 4 "
    echo " export MIC_PPN=2"
    echo " export MIC_OMP_NUM_THREADS=60"
    echo " export OMP_NUM_THREADS=2"
    echo " ibrun.symm -m ./mpihello.mic -c ./mpihello.host "
    echo " "
    echo "This will start 8 mpi tasks on 4 nodes with 2 threads per host "
    echo "task and 2 mpi tasks on 4 MIC cards with 60 threads per MIC task "
    echo "resulting in 40 total mpi tasks. "
    echo " "
    echo "Note:  ibrun.symm does not support the -n or -o arguments. "
}

nlocal=$(hostname -f)
nA=($(builtin echo "$nlocal" | tr '.' ' '))
first=${nA[0]}
SYSHOST=${nA[1]}

fqdn="$SYSHOST.tacc.utexas.edu"


ADMIN_stampede="/home1/moduleData"
ADMIN_ls4="/home1/moduleData"
ADMIN_longhorn="/share/tacc_admin"
eval "ADMIN_DIR=\$ADMIN_$SYSHOST"




## Look through all the arguments to ibrun.  If the user asked for help (-h)
## print the help and then exit immediately.

# echo "ARG1 = $1 "

if [ "$1" != "-m" -a "$1" != "-c" ]; then
    usage
    exit 0
fi

# Check for some command line switches before the executable
stop_parsing=0

mexec=""
hexec=""

while [ $stop_parsing -ne 1 ]
do
    case "$1" in
	-m)
	    shift
	    mexec=$1
	    shift
	    ;;
	-c)
	    shift
	    hexec=$1
	    shift
	    ;;
	*)
            stop_parsing=1
	    ;;
    esac
done

pe_startTime=`date +%s`

# --------------------------------------------------------
# Check for user provided MIC_PPN or MIC_MY_NSLOTS 
#  and MIC_OMP_NUM_THREADS
# --------------------------------------------------------
if [ "x$MIC_MY_NSLOTS" == "x" -a "x$MIC_PPN" == "x" ]; then
   MIC_PPN=4
fi
if [ x"$MIC_OMP_NUM_THREADS" == "x" ]; then
   MIC_OMP_NUM_THREADS=30
fi

# Get the PE hostfile, number of slots and wayness from the environment

SCHEDULER=SLURM

    BATCH_JOB_ID=$SLURM_JOBID
    NSLOTS_BATCH=$SLURM_NPROCS
    #Parse the SLURM_TASKS_PER_NODE string to get # of node clusters
    # e.g.  6(2x),5(2x) -- 1st 2 nodes run 6 tasks, next 2 nodes run 5 tasks
    declare -a node_clusters=(`echo $SLURM_TASKS_PER_NODE | sed -e's/,/ /g'`)
#    echo "DEBUG: ${node_clusters[@]} "
    #Set the wayness for each node cluster using one env
    # Format of node_tasks_ppn_info = 
    # "{# of tasks per node},{#initial task id}_[repeats if necessary]"
    #                                         ^
    #No spaces are allowed in env variables that build_env.pl handles.
    # So, an "_" is used in place of a space.

    #Initialize variables needed to setup node_tasks_ppn_info
    node_tasks_ppn_info=""
    task_count=0

    #Loop over node clusters
    for nodes in ${node_clusters[@]}; do
      #Get the number of tasks per node
      tasks_ppn_cluster=`echo $nodes | awk -F '(' '{print $1}'`

      #Determine how many nodes are in this cluster, i.e. have the same number of 
      # tasks/node 
      if [[ `echo $nodes | grep x` ]]; then
        node_count=`echo $nodes | sed -e's/.*x\([0-9]\+\).*/\1/'`
      else
       node_count=1
      fi

      #We have to set this up for each node when running with MIC
      # Loop over the nodes in the node cluster

      node_index=0
      while [ $node_index -lt $node_count ]; do
        #Set the number of tasks/node for this node and the task id 
        # at which it starts
        node_tasks_ppn_info="${node_tasks_ppn_info}${tasks_ppn_cluster},${task_count}_"

        #Increment the task counter by the number of tasks per node
        let "task_count = $task_count + $tasks_ppn_cluster "

        #Increment the task counter by the number of tasks on the mic
        let "task_count = $task_count + $MIC_PPN "

        let "node_index=$node_index+1"
      done
    done
    
    #Export as an env variable to pass along to each task
    export NODE_TASKS_PPN_INFO="\"$node_tasks_ppn_info\""

echo "TACC: Starting up job $BATCH_JOB_ID"

srq_size=2048
default_time_out=23

# Find out which MPI stack we're using

MODE=$TACC_MPI_GETMODE
if [ -z $MODE ]; then
    MODE=`getmode.sh`
fi 

# Set our files and directories

home_batch_dir="$HOME/.slurm"

if [ ! -d $home_batch_dir ]; then
    mkdir -p $home_batch_dir
fi

# FYI: mktemp generates a filename with random numbers/letters
# replacing the XXX

hostfile_tacc=`mktemp $home_batch_dir/job.$BATCH_JOB_ID.hostlist.XXXXXXXX`
nslotsfile_tacc=`mktemp $home_batch_dir/job.$BATCH_JOB_ID.info.XXXXXXXX`
configfile_tacc=`mktemp $home_batch_dir/config_file.$BATCH_JOB_ID.XXXXXXXX`

# Just to be sure, remove the host and nslots files in case they
# already exist.  This should never happen...

if [ -f $nslotsfile_tacc ]; then
    rm $nslotsfile_tacc
fi

if [ -f $hostfile_tacc ]; then
    rm $hostfile_tacc
fi

if [ -f $configfile_tacc ]; then
    rm $configfile_tacc
fi

# Set local LD_PRELOAD with DARSHAN
if [ x$LD_PRELOAD == "x" ]; then
    IBRUN_LD_PRELOAD=""
else
    IBRUN_LD_PRELOAD="$LD_PRELOAD"
    unset LD_PRELOAD
fi

if [ x$TACC_DARSHAN_LIB != "x" ]; then
    if [ x$IBRUN_LD_PRELOAD == "x" ]; then
	IBRUN_LD_PRELOAD="${TACC_DARSHAN_FORTRAN_LIB}:${TACC_DARSHAN_LIB}"
    else
	IBRUN_LD_PRELOAD="${IBRUN_LD_PRELOAD}:${TACC_DARSHAN_FORTRAN_LIB}:${TACC_DARSHAN_LIB}"
    fi
fi

if [ -n "$IBRUN_LD_PRELOAD" ]; then
    MVAPICH_LD_PRELOAD="LD_PRELOAD=$IBRUN_LD_PRELOAD"
    OPENMPI_LD_PRELOAD="-x LD_PRELOAD=$IBRUN_LD_PRELOAD"
fi

# ------------------------------
# Check for user provided NSLOTS
# ------------------------------
if [ x"$MY_NSLOTS" == "x" ]; then
    if [ -f $nslotsfile_tacc ]; then
	MY_NSLOTS=`cat $nslotsfile_tacc`
    else
	MY_NSLOTS=$NSLOTS_BATCH
    fi
fi


if [ x"$MODE" == "xmvapich2_slurm" -o x"$MODE" == "xmvapich2_ssh" ]; then
   echo "ERROR:  Mvapich2 module loaded"
   echo "          ibrun.symm only works with Intel MPI at this time"
   exit 1

elif [ x"$MODE" == "ximpi_hydra" ]; then

   #Ensure the env is setup for host/mic mpi
   export I_MPI_FABRICS=shm:ofa
   export I_MPI_MIC=1
   export I_MPI_OFA_ADAPTER_NAME=mlx4_0
#   export I_MPI_DEBUG=2

   #Get a list of hosts
   declare -a hostlist=(`scontrol show hostname $SLURM_NODELIST `)
   if [ $? -ne 0  ];then
      echo "TACC: Error -> slurm host list unavailable"
      exit 1
   fi

   #Create a list of bridge hosts
   declare -a br0_hostlist=(`scontrol show hostname $SLURM_NODELIST | sed -e's/$/-br0/'`)

   #Create a list of mic hosts
   #For now, only 1 mic per node
   #We'll have to change this when we have 2 mic nodes
   declare -a mic0_hostlist=(`scontrol show hostname $SLURM_NODELIST | sed -e's/$/-mic0/'`)
#   declare -a mic1_hostlist=(`scontrol show hostname $SLURM_NODELIST | sed -e's/$/-mic1/'`)

   #Set up the mic environment
   if [ -z "${MIC_ENV_PREFIX}" ]; then
     export MIC_ENV_PREFIX=MIC
   fi
   ENV_MIC=`env | grep -i ^${MIC_ENV_PREFIX}_ | egrep -v MIC_ENV_PREFIX | awk -vORS=' ' -v pfx=${MIC_ENV_PREFIX} -F= '{b=$1; a=substr($1,length(pfx)+2,length($1));  if (length($2) > 0 ) print " -env "a" "$2" "; }'`

   #Set KMP_AFFINITY and I_MPI_PIN_MODE at the beginning of ENV_MIC
   # If there are any user settings, e.g. MIC_KMP_AFFINITY, they will override these defaults
   ENV_MIC="-env KMP_AFFINITY balanced -env I_MPI_PIN_MODE mpd $ENV_MIC"
   

#    echo "DEBUG: ${hostlist[@]} "

   #Run using mpiexec.hydra
   #Initialize the configfile
   touch $configfile_tacc
   echo "# Using command: mpiexec.hydra -configfile <config_file_name>"  >> $configfile_tacc 

   #Initialize the hostlist index and populate the configfile
   host_id=0
   #Track # of tasks for MY_NSLOTS and flag to end host tasks
   task_id=0
   nslots_flag=0

   #Only build the hostlist if there is a host executable
   # It's not possible yet to run on multiple MIC's without
   # at least one MPI task on the first host!
   if [ "x$hexec" != "x" ]; then
     #Build the hostlist using the SLURM_TASKS_PER_NODE syntax
     for nodes in ${node_clusters[@]}; do

       #Get the task count and node count for each node cluster
       task_count=`echo $nodes | awk -F '(' '{print $1}'`
       if [[ `echo $nodes | grep x` ]]; then
         node_count=`echo $nodes | sed -e's/.*x\([0-9]\+\).*/\1/'`
       else
         node_count=1
       fi
#DEBUG       echo "DEBUG: nodes=$nodes task_count=$task_count  node_count=$node_count"

       #Build the host list to match tasks per node
       for i in `seq 0 $((node_count-1))`; do
         #Build command for host
         #First check to see if we exceed MY_NSLOTS
         task_id=$((task_id+task_count))
         if [ "$MY_NSLOTS" -lt "$task_id" ]; then  
            task_count=$((task_count + MY_NSLOTS - task_id))
         fi
         if [ "$nslots_flag" -eq 0 ]; then  
            echo " -n $task_count -host ${br0_hostlist[${host_id}]} $hexec "  >> $configfile_tacc 
         fi
         #Build command for mic
         if [ "x$mexec" != "x" ]; then
           cmd=" $cmd -n $MIC_PPN -host ${mic0_hostlist[${host_id}]} "
           cmd=" $cmd $ENV_MIC "
           cmd=" $cmd $mexec "
           echo "$cmd " >> $configfile_tacc 
         fi
         cmd=""
         #If we exceeded MY_NSLOTS -- don't set up any more host tasks
         if [ "$MY_NSLOTS" -lt "$task_id" ]; then nslots_flag=1; fi  
         ((host_id++))
       done
     done

   else
   #Set up run for one mic card on first host
     cmd=" $cmd -n $MIC_PPN -host ${mic0_hostlist[${host_id}]} "
     cmd=" $cmd $ENV_MIC "
     cmd=" $cmd $mexec "
     echo "$cmd " >> $configfile_tacc 
   fi

   echo " " >> $configfile_tacc 

   #Ensure the env is setup for host/mic mpi
   export I_MPI_FABRICS=shm:ofa
   export I_MPI_MIC=1
   export I_MPI_OFA_ADAPTER_NAME=mlx4_0
#DEBUG   export I_MPI_DEBUG=2

else
    # Some other MPI stack? fail.
    echo "TACC: Could not determine MPI stack. Exiting!"
    exit 1
fi

#echo "TACC: Setup complete."

#------------------------------
# Let's finally launch the job
#------------------------------

## Do some error checking of the user's arguments to ibrun.
res=0

if [ -n "$LMOD_CMD" ]; then
    export LMOD_CMD=$LMOD_CMD
fi

pe_mapD="$ADMIN_DIR/reverseMapT"

pe_fn=`mktemp $home_batch_dir/job.$BATCH_JOB_ID.usage.XXXXXXXX`
mv $pe_fn $pe_fn.lua
pe_fn=$pe_fn.lua

checkExec --map $pe_mapD -- $hexec

parseLDD --map $pe_mapD --start $pe_startTime --runTime 0.0 --fn $pe_fn -- $hexec

if [ -n "$TACC_IBWRAPPER_DEBUG" ]; then
    exit
fi

## Modify $hostfile_tacc if user passed special options to ibrun

echo "TACC: Starting parallel tasks..."


# Launch a job with mvapich2+MPD's mpiexec command
if [ x"$MODE" == "ximpi_hydra" ]; then

    #Run
    echo  "  $MPICH_HOME/intel64/bin/mpiexec.hydra -configfile $configfile_tacc "
   
    $MPICH_HOME/intel64/bin/mpiexec.hydra -configfile $configfile_tacc
    res=$?
else
    echo -e "TACC: Could not determine which MPI stack to use.\nTACC:Exiting.\n"
    res=1
fi


pe_endTime=`date +%s`
pe_runTime=`echo "$pe_endTime - $pe_startTime" | bc -q`

parseLDD --map $pe_mapD --start $pe_startTime --runTime $pe_runTime --fn $pe_fn -- $hexec

if [ $res -ne 0 ]; then
    echo "TACC: MPI job exited with code: $res"
fi


#-----------------------
# Job tear-down/cleanup
#-----------------------

###echo "TACC: Shutting down parallel environment."
###
###if [ x"$MODE" == "xmvapich2_mpd" ]; then
###    mpdallexit 
###elif [ x"$MODE" == "xmvapich1_ssh" -o x"$MODE" == "xmvapich2_ssh" ]; then
###    /bin/true
###elif [ x"$MODE" == "xmvapich1_devel_ssh" ]; then
###    /bin/true
###elif [ x"$MODE" == "xopenmpi_ssh" -o x"$MODE" == "xopenmpi_1.3_ssh" ]; then
###    /bin/true
###else
###    echo "TACC: You should not see this message! Please contact TACC consulting and send us your jobscript."
###    exit 1
###fi

if [ x"$TACC_KEEP_FILES" != "x" ]; then
    if [ -f $nslotsfile_tacc ]; then
	rm $nslotsfile_tacc
    fi
    if [ -f $hostfile_tacc ]; then
	rm $hostfile_tacc
    fi
fi

echo " "
echo "TACC: Shutdown complete. Exiting." 
exit $res

