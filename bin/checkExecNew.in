#!@path_to_lua@/lua
-- -*- lua -*-
local cmd = arg[0]

local i,j = cmd:find(".*/")
local cmd_dir = "./"
if (i) then
   cmd_dir = cmd:sub(1,j)
end
package.path = cmd_dir .. "?.lua;" .. package.path


require("strict")
require("string_split")
require("fileOps")
require("capture")
require("readRMap")
require("VarDump")
local Dbg       = require("Dbg")
local Optiks    = require("Optiks")
local getenv    = os.getenv
local concatTbl = table.concat
s_master        = {}
ignoreT = {
   tacc_affinity     = 1,
   getmode_affinity  = 1,
}

ignoreLines = {
   "^LMOD",
   "^export",
   "^MODULEPATH",
}
   


activeList = {}

function masterTbl()
   return s_master
end

function regularize(value)
   value = value:gsub("//+","/")
   value = value:gsub("/%./","/")
   value = value:gsub("/$","")
   value = abspath(value)
   return value
end

function findEnvVersions(mpiStack, compiler)
   local sysT = {mpi="unknown",comp="unknown"}
   local lmod_cmd = getenv("LMOD_CMD")
   if (lmod_cmd == nil) then return sysT end
   local s        = capture(lmod_cmd .. " bash tablelist 2>&1 ")

   local a = {}
   for l in s:split("\n") do
      local keep = true
      for i = 1,#ignoreLines do
         if (l:find(ignoreLines[i])) then
            keep = false
            break
         end
      end
      if (keep) then
         a[#a+1] = l
      end
   end

   s = concatTbl(a,"\n")
   assert(loadstring(s))()
   sysT.mpi  = mpiStack .."/"..tostring(activeList[mpiStack])
   sysT.comp = compiler .."/"..tostring(activeList[compiler])

   return sysT
end

function checkForMissingLibraries(ldd)
   local missing = false
   for l in ldd:split("\n") do
      if (l:find("=>  *not found")) then
         missing = true
         break
      end
   end

   return missing

end

function matchExecWmodules(reverseMapT, ldd)

   local execT = {}

   local dbg = Dbg:dbg()
   dbg.start("matchExecWmodules(reverseMapT, ldd)")
   
   local libPathA = {}
   for lib in ldd:split("\n") do
      lib = lib:gsub(".*=> *","")
      lib = lib:gsub("%(0x.*$","")
      lib = regularize(lib)
      libPathA[#libPathA+1] = lib
      dbg.print("Lib: ",lib,"\n")
   end

   
   for i = 1, #libPathA do
      local dir, lib = splitFileName(libPathA[i])
      local pkgInfo = reverseMapT[dir]
      if (pkgInfo) then
         local t            = execT[pkgInfo.pkg] or {}
         local libA         = t.libA or {}
         t.flavor           = pkgInfo.flavor
         libA[#libA+1]      = lib:trim()
         t.libA             = libA
         execT[pkgInfo.pkg] = t
      end
   end
   
   vardumpT(execT)


   ---if (not mpiN) then
   ---   return execT
   ---end
   ---
   ---
   ---lib = lib:gsub("/lib/" .. libName .. ".*","")
   ---lib = lib:gsub("/lib/shared/" .. libName .. ".*","")
   ---
   ---if (dbg > 0) then
   ---   print ("lib:",lib)
   ---end
   ---
   ---local pathA = {}
   ---
   ---for p in lib:split("/") do
   ---   pathA[#pathA+1] = p
   ---end
   ---
   ---local execT = {}
   ---execT.mpi  = pathA[#pathA-1] .."-".. pathA[#pathA]
   ---
   ---local _,_,c,v = pathA[#pathA-2]:find("([a-zA-Z]*)-?(.*)")
   ---v = v:gsub("-[0-9]*","")
   ---v = v:gsub("_",".")
   ---
   ---execT.comp = tostring(c).."-"..tostring(v)
   
   return execT
end

function main()

   options()
   local cmd       = "unknown"
   local masterTbl = masterTbl()
   local pargs     = masterTbl.pargs
   local dbg       = Dbg:dbg()
   if (masterTbl.debug or getenv("TACC_IBWRAPPER_DEBUG")) then
      dbg:activateDebug(1)
   end
   
   dbg.start("checkExec(\""..concatTbl(pargs,"\", \"").."\")")


   for i = 1, #pargs do
      if (not ignoreT[pargs[i]]) then
         cmd = pargs[i]
         break;
      end
   end
   local path=getenv("PATH") or ""

   local execPath = findInPath(cmd,path)

   if (execPath == "") then
      io.stdout:write("******************************************************\n",
                      "Could not find: \"",tostring(cmd),"\" in your PATH\n",
                      "******************************************************\n")
      dbg.fini()
      return 1
   end


   local reverseMapT = readRMap(masterTbl.reverseMapD)

   local ldd = capture("ldd "..execPath)

   if (checkForMissingLibraries(ldd)) then
      io.stdout:write("******************************************************\n",
                      " There are missing shared libraries \n",
                      "******************************************************\n")
      dbg.fini()
      return 1
   end
      


   local mpiStack = getenv("TACC_FAMILY_MPI")      or "unknown"
   local compiler = getenv("TACC_FAMILY_COMPILER") or "unknown"
   local sysT     = findEnvVersions(mpiStack, compiler)
   local status = 0
   if (sysT.mpi == "unknown") then
      dbg.fini()
      return status
   end

   

   dbg.print("sysT.mpi: ",tostring(sysT.mpi), ", sysT.comp: ",tostring(sysT.comp),"\n")

   local execT = matchExecWmodules(reverseMapT,ldd)
   
   dbg.print("execT.mpi: ",tostring(execT.mpi), ", execT.comp: ",tostring(execT.comp),"\n")

   --
   --if (execT == nil) then
   --   dbg.fini()
   --   return status
   --end
   --
   --if (sysT.mpi ~= execT.mpi) then
   --   io.stdout:write("******************************************************\n",
   --                   " WARNING: Your MPI Environment is :       ",sysT.mpi,"\n",
   --                   "          Your executable was built with: ",execT.mpi,"\n",
   --                   "******************************************************\n")
   --   status = 1
   --end      
   --                   
   --
   --
   --if (sysT.comp ~= execT.comp) then
   --   io.stdout:write("******************************************************\n",
   --                   " WARNING: Your Compiler Environment is :  ",sysT.comp,"\n",
   --                   "          Your executable was built with: ",execT.comp,"\n",
   --                   "******************************************************\n")
   --   status = 1
   --end
   dbg.fini()
   return status
end

function options()
   local masterTbl     = masterTbl()
   local Version       = "1.6.2"
   local usage         = "Usage: checkExec [options] exec"
   local cmdlineParser = Optiks:new{usage=usage, version=Version}

   cmdlineParser:add_option{ 
      name   = {'-v','--verbose'},
      dest   = 'verbosityLevel',
      action = 'count',
   }

   cmdlineParser:add_option{ 
      name   = {'-d','--debug'},
      dest   = 'debug',
      action = 'store_true',
   }


   cmdlineParser:add_option{ 
      name   = {'-m','--reverseMap', '--map'},
      dest   = 'reverseMapD',
      action = 'store',
      help   = "reverseMap directory",
   }


   local optionTbl, pargs = cmdlineParser:parse(arg)

   for v in pairs(optionTbl) do
      masterTbl[v] = optionTbl[v]
   end
   masterTbl.pargs = pargs

end

local status = main()
if (status ~=0) then
   os.exit(status)
end
