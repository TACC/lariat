#!@path_to_lua@/lua
-- -*- lua -*-
local cmd = arg[0]

local i,j = cmd:find(".*/")
local cmd_dir = "./"
if (i) then
   cmd_dir = cmd:sub(1,j)
end
package.path = cmd_dir .. "?.lua;" .. package.path

require("strict")

require("capture")
require("fileOps")
require("serializeTbl")
require("string_split")
require("string_trim")
require("VarDump")
local Dbg       = require("Dbg")
local Optiks    = require("Optiks")
local Version   = "1.4"
local concatTbl = table.concat
local getenv    = os.getenv
local lfs       = require("lfs")
local master    = {}
local posix     = require("posix")

ignoreT = {
   tacc_affinity     = 1,
   getmode_affinity  = 1,
}

reverseMapT = {}

DirKeepPass1 = {
   "^/opt/apps/",
   "^/share1/apps",
   "^/work/00515/mclay/apps",
}
   

IgnoreModA = {
   "^intel/",
   "^gcc/",
   "^mvapich/",
   "^mvapich2/",
   "^openmpi/",
}   

function isExec(fn)
   if (fn == nil) then return false end
   local result = posix.access(fn,"rx")
   return result
end

function keepModule(mod)
   for i = 1, #IgnoreModA do
      if (mod:find(IgnoreModA[i])) then
         return false
      end
   end
   return true
end

function regularize(value)
   value = value:gsub("//+","/")
   value = value:gsub("/%./","/")
   value = value:gsub("/$","")
   return value
end

function masterTbl()
   return master
end

function main()

   options()
   local masterTbl  = masterTbl()
   local pargs      = masterTbl.pargs
   local cmd        = nil

   -- open reverseMap file and read it in.

   local reverseMapFn = pathJoin(masterTbl.reverseMapD,"reverseMapT.lua")
   local rmF          = io.open(reverseMapFn,"r")
   if (not rmF) then
      reverseMapFn = pathJoin(masterTbl.reverseMapD,"reverseMapT.old.lua")
      rmF          = io.open(reverseMapFn,"r")
   end

   if (rmF) then
      local whole  = rmF:read("*all")
      rmF:close()

      assert(loadstring(whole))()
   end


   -- find user command from command line.

   for i = 1, #pargs do
      local f = barefilename(pargs[i])
      if (not ignoreT[f]) then
         cmd = pargs[i]
         break
      end
   end

   if (cmd == nil) then return end

   local path      = getenv("PATH") or ""
   local execPath  = findInPath(cmd,path)
   if (execPath == nil or execPath == "") then return end
   execPath        = abspath(execPath)
   if (not isExec(execPath)) then return end

   local attrT     = lfs.attributes(execPath)
   local execEpoch = "unknown"
   if (attrT) then
      execEpoch = attrT.modification
   end


   -- Determine if an executable or shell script
   local ldd = capture("ldd "..execPath)
   local userT = {}
   userT.execType = "user:binary"
   if (ldd:find("not a dynamic executable")) then
      userT.execType = "user:script"
   else
      local pkg = reverseMapT[regularize(dirname(execPath))]
      if (pkg) then
         userT.execType = "system:" .. pkg.pkg
      end
   end



   -- Add command line options to userT
   userT.numCores   = getenv("NSLOTS") or "0"
   userT.numNodes   = getenv("NHOSTS") or "0"
   userT.account    = getenv("SGE_ACCOUNT") or "unknown"
   userT.jobID      = getenv("JOB_ID")      or "unknown"
   userT.user       = getenv("USER")        or "unknown"
   userT.startTime  = os.date("%c",masterTbl.startTime)
   userT.startEpoch = masterTbl.startTime
   userT.runTime    = masterTbl.runTime
   userT.exec       = execPath
   userT.execEpoch  = execEpoch
   userT.execModify = os.date("%c",execEpoch)

   local HashSum = findInPath("sha1sum")
   if (HashSum ~= "") then
      local sha1 = capture(HashSum .. " " .. execPath)
      local i,j  = sha1:find(" ")
      userT.sha1 = sha1:sub(1,i-1)
   end
   

   local pkgT     = {}
   local libPathA = {}
   for l in ldd:split("\n") do
      l = l:gsub(".*=> *","")
      l = l:gsub("%(0x.*$","")
      for d = 1, #DirKeepPass1 do
         if (l:find(DirKeepPass1[d]) == 1) then
            libPathA[#libPathA+1] = l
            break;
         end
      end
   end

   userT.sizeT = { text = 0, data = 0, bss = 0}
   if (userT.execType == "user:binary") then
      local sizeC = capture("size ".. execPath)
      local icount = 0
      for l in sizeC:split("\n") do
         icount = icount+1
         if (icount == 2) then
            local _,_, txt,dat,bss = l:find("%s*(%d+)%s+(%d+)%s+(%d+)")
            userT.sizeT = { text = txt, data= dat, bss = bss}
            break
         end
      end
   end


   for i = 1, #libPathA do
      local dir, lib = splitFileName(libPathA[i])
      local pkg = reverseMapT[regularize(dir)]
      if (pkg and keepModule(pkg.pkg)) then
         local t       = pkgT[pkg.pkg] or {}
         local libA    = t.libA or {}
         t.flavor      = pkg.flavor
         libA[#libA+1] = lib:trim()
         t.libA        = libA
         pkgT[pkg.pkg] = t
      end
   end

   userT.pkgT = pkgT
   local s = serializeTbl{indent=true, name="userT", value=userT}
   if (masterTbl.resultFn) then
      local f = io.open(masterTbl.resultFn,"w")
      if (f) then
         f:write(s)
         f:close()
      end
   end
end

function options()
   local masterTbl = masterTbl()
   local usage         = "Usage: moduleSymlink [options] pkgName pkgVersion"
   local cmdlineParser = Optiks:new{usage=usage, version=Version}

   cmdlineParser:add_option{ 
      name   = {'-v','--verbose'},
      dest   = 'verbosityLevel',
      action = 'count',
   }

   cmdlineParser:add_option{ 
      name   = {'-s','--start'},
      dest   = 'startTime',
      action = 'store',
      help   = "epoch time for job start",
   }

   cmdlineParser:add_option{ 
      name   = {'-r','--runTime'},
      dest   = 'runTime',
      action = 'store',
      help   = "job time in seconds",
   }

   cmdlineParser:add_option{ 
      name   = {'-f','--fn'},
      dest   = 'resultFn',
      action = 'store',
      help   = "result File Name",
   }

   cmdlineParser:add_option{ 
      name   = {'-m','--reverseMap', '--map'},
      dest   = 'reverseMapD',
      action = 'store',
      help   = "reverseMap directory",
   }

  


   local optionTbl, pargs = cmdlineParser:parse(arg)

   for v in pairs(optionTbl) do
      masterTbl[v] = optionTbl[v]
   end
   masterTbl.pargs = pargs

end
main()
